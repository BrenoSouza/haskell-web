
==================== FINAL INTERFACE ====================
2018-07-29 16:53:39.3430607 UTC

interface main:HeapImpl 8043
  interface hash: 8e27754184542949310ef2363ca9ef1c
  ABI hash: 270ac267cdbb9fd1bc0006535c5c2d89
  export-list hash: 13f0850a3973320a6873a5e687cbfb64
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: d4f10714787157b039ebec0245d4421d
  opt_hash: 2c98c95d41c045ae9c2fb565ec8aabc6
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  sig of: Nothing
  used TH splices: False
  where
exports:
  HeapImpl.delHeap
  HeapImpl.emptyHeap
  HeapImpl.findHeap
  HeapImpl.heapEmpty
  HeapImpl.insHeap
  HeapImpl.Heap
module dependencies:
package dependencies: base-4.11.1.0* ghc-prim-0.5.2.0
                      integer-gmp-1.0.2.0
orphans: base-4.11.1.0:GHC.Float base-4.11.1.0:GHC.Base
family instance modules: base-4.11.1.0:Control.Applicative
                         base-4.11.1.0:Data.Functor.Const
                         base-4.11.1.0:Data.Functor.Identity base-4.11.1.0:Data.Monoid
                         base-4.11.1.0:Data.Semigroup.Internal base-4.11.1.0:GHC.Generics
                         base-4.11.1.0:GHC.IO.Exception
import  -/  base-4.11.1.0:GHC.Base b7dd14d8fe8d606dde5678ea6b0575e9
import  -/  base-4.11.1.0:GHC.Err 97cd376c529926d7dcbd3f06020fe0fc
import  -/  base-4.11.1.0:GHC.Num 5de8df0185e7e8d8ec29b3c61e2c8606
import  -/  base-4.11.1.0:GHC.Show 6211aec7cccd267a5ee999e4414d7b90
import  -/  base-4.11.1.0:Prelude aca391812f777207b15d62bb5b9feb63
import  -/  ghc-prim-0.5.2.0:GHC.Classes f7d67fd97d5a20e9252c9597d1aa387b
d74b655e611ea45eef106ddcc1c9dcef
  $fShowHeap :: GHC.Show.Show a => GHC.Show.Show (HeapImpl.Heap a)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(C(U))),A,A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ a (v :: GHC.Show.Show a).
                  @ (HeapImpl.Heap a)
                  (HeapImpl.$fShowHeap_$cshowsPrec @ a v)
                  (HeapImpl.$fShowHeap_$cshow @ a v)
                  (HeapImpl.$fShowHeap_$cshowList @ a v) -}
7bbeee80aa3c80d07a0fb29a26807adb
  $fShowHeap1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
6d483de99c6376381ae7c3d0eac765ff
  $fShowHeap2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("HP "#) -}
001e0275ee00fc8c280eb8a501eec8c0
  $fShowHeap3 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 11#) -}
fd39c0bb1046c447628e963481292c54
  $fShowHeap4 :: [GHC.Types.Char] -> [GHC.Types.Char]
  {- Arity: 1,
     Unfolding: (GHC.Base.++ @ GHC.Types.Char HeapImpl.$fShowHeap5) -}
4b3eecde4e6bc6c5ee2a59fdeb8129ae
  $fShowHeap5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# HeapImpl.$fShowHeap6) -}
0a32755e1bd56bd3aa1751b9f9b3dc13
  $fShowHeap6 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("EmptyHP"#) -}
d74b655e611ea45eef106ddcc1c9dcef
  $fShowHeap_$cshow ::
    GHC.Show.Show a => HeapImpl.Heap a -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a ($dShow :: GHC.Show.Show a) (x :: HeapImpl.Heap a) ->
                 HeapImpl.$fShowHeap_$s$cshowsPrec
                   @ a
                   x
                   0#
                   $dShow
                   (GHC.Types.[] @ GHC.Types.Char)) -}
d74b655e611ea45eef106ddcc1c9dcef
  $fShowHeap_$cshowList ::
    GHC.Show.Show a => [HeapImpl.Heap a] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (ls :: [HeapImpl.Heap a])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (HeapImpl.Heap a)
                   (HeapImpl.$fShowHeap_$cshowsPrec @ a $dShow HeapImpl.$fShowHeap1)
                   ls
                   s) -}
d74b655e611ea45eef106ddcc1c9dcef
  $fShowHeap_$cshowsPrec ::
    GHC.Show.Show a =>
    GHC.Types.Int -> HeapImpl.Heap a -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><L,1*U(U)><S,1*U>,
     Unfolding: (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (ds :: GHC.Types.Int)
                   (ds1 :: HeapImpl.Heap a) ->
                 case ds1 of wild {
                   HeapImpl.EmptyHP -> HeapImpl.$fShowHeap4
                   HeapImpl.HP b1 b2 b3 b4
                   -> case ds of wild1 { GHC.Types.I# x ->
                      let {
                        f :: GHC.Base.String -> GHC.Base.String
                        = GHC.Show.showsPrec @ a $dShow HeapImpl.$fShowHeap3 b1
                      } in
                      let {
                        f1 :: GHC.Base.String -> GHC.Base.String
                        = HeapImpl.$fShowHeap_$s$cshowsPrec @ a b3 11# $dShow
                      } in
                      let {
                        g :: GHC.Base.String -> GHC.Base.String
                        = HeapImpl.$fShowHeap_$s$cshowsPrec @ a b4 11# $dShow
                      } in
                      let {
                        p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,U> -}
                        = \ (x1 :: GHC.Base.String) ->
                          GHC.CString.unpackAppendCString#
                            HeapImpl.$fShowHeap2
                            (f (GHC.Types.:
                                  @ GHC.Types.Char
                                  GHC.Show.showSpace1
                                  (case b2 of ww2 { GHC.Types.I# ww3 ->
                                   case GHC.Show.$wshowSignedInt
                                          11#
                                          ww3
                                          (GHC.Types.:
                                             @ GHC.Types.Char
                                             GHC.Show.showSpace1
                                             (f1
                                                (GHC.Types.:
                                                   @ GHC.Types.Char
                                                   GHC.Show.showSpace1
                                                   (g x1)))) of ww4 { (#,#) ww5 ww6 ->
                                   GHC.Types.: @ GHC.Types.Char ww5 ww6 } })))
                      } in
                      case GHC.Prim.>=# x 11# of lwild {
                        DEFAULT -> p
                        1#
                        -> \ (x1 :: GHC.Base.String) ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.$fShow(,)4
                             (p (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 x1)) } } }) -}
d74b655e611ea45eef106ddcc1c9dcef
  $fShowHeap_$s$cshowsPrec ::
    HeapImpl.Heap a
    -> GHC.Prim.Int# -> GHC.Show.Show a => GHC.Show.ShowS
  {- Arity: 3, Strictness: <S,1*U><L,U><L,U(C(C1(C(U))),A,A)> -}
e2330dbcf08d0d566a4f9938e0469215
  $tc'EmptyHP :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12949284830065016226##
                   7915573851555812312##
                   HeapImpl.$trModule
                   HeapImpl.$tc'EmptyHP2
                   1#
                   HeapImpl.$tc'EmptyHP1) -}
0283a89e167cfe07d442d1e7ae75667f
  $tc'EmptyHP1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m1, Inline: [~] -}
a84c31fb74d1c35e2f2ca64522725680
  $tc'EmptyHP2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS HeapImpl.$tc'EmptyHP3) -}
07ad457a065a124aa9ba33f62458ffc2
  $tc'EmptyHP3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'EmptyHP"#) -}
96fd141d0b065d2944caeb1aee0c0507
  $tc'HP :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12843027183642049293##
                   6220900599108392066##
                   HeapImpl.$trModule
                   HeapImpl.$tc'HP2
                   1#
                   HeapImpl.$tc'HP1) -}
48173e9e4b3c373e14115f4525eaf859
  $tc'HP1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
8ec83cbc16e62668ccb827cac0fc021b
  $tc'HP2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS HeapImpl.$tc'HP3) -}
4b77a903b4c5d2919c3636b92e4cc21c
  $tc'HP3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'HP"#) -}
d2db435ed51fd2ffdc9a0d62041222d5
  $tcHeap :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4296364228924562344##
                   2276646089472472164##
                   HeapImpl.$trModule
                   HeapImpl.$tcHeap1
                   0#
                   GHC.Types.krep$*Arr*) -}
e1bee73914c48d84f8901150bf35668f
  $tcHeap1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS HeapImpl.$tcHeap2) -}
22e8e8b67aa7ee6269e06fd0d55e95c3
  $tcHeap2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Heap"#) -}
2017d3e0668ac42bb5d2ef91747b42a7
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   HeapImpl.$trModule3
                   HeapImpl.$trModule1) -}
8ef421b740228285455a36bd29d5254b
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS HeapImpl.$trModule2) -}
cfbe31da07da13ea1d27213e15b2c2c0
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("HeapImpl"#) -}
659da3a7c43d4d6b8d8930ec8cea65d4
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS HeapImpl.$trModule4) -}
4c6cc116022dcb049955bd6f3d087e24
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("main"#) -}
163d2dd5ff95b9d2ede5986d0d914926
  $wmakeHP ::
    a -> HeapImpl.Heap a -> HeapImpl.Heap a -> HeapImpl.Heap a
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><S,1*U><S,1*U>m2,
     Inline: [0],
     Unfolding: (\ @ a
                   (w :: a)
                   (w1 :: HeapImpl.Heap a)
                   (w2 :: HeapImpl.Heap a) ->
                 case w1 of wild {
                   HeapImpl.EmptyHP
                   -> case w2 of wild1 {
                        HeapImpl.EmptyHP
                        -> HeapImpl.HP
                             @ a
                             w
                             HeapImpl.delHeap1
                             (HeapImpl.EmptyHP @ a)
                             (HeapImpl.EmptyHP @ a)
                        HeapImpl.HP ds rank ds1 ds2
                        -> case rank of wild2 { GHC.Types.I# y ->
                           case GHC.Prim.>=# 0# y of lwild {
                             DEFAULT
                             -> HeapImpl.HP @ a w HeapImpl.delHeap1 wild1 (HeapImpl.EmptyHP @ a)
                             1#
                             -> HeapImpl.HP
                                  @ a
                                  w
                                  (GHC.Types.I# (GHC.Prim.+# y 1#))
                                  (HeapImpl.EmptyHP @ a)
                                  wild1 } } }
                   HeapImpl.HP ds rank ds1 ds2
                   -> case w2 of wild1 {
                        HeapImpl.EmptyHP
                        -> case rank of wild2 { GHC.Types.I# x ->
                           case GHC.Prim.>=# x 0# of lwild {
                             DEFAULT
                             -> HeapImpl.HP
                                  @ a
                                  w
                                  (GHC.Types.I# (GHC.Prim.+# x 1#))
                                  (HeapImpl.EmptyHP @ a)
                                  wild
                             1#
                             -> HeapImpl.HP
                                  @ a
                                  w
                                  HeapImpl.delHeap1
                                  wild
                                  (HeapImpl.EmptyHP @ a) } }
                        HeapImpl.HP ds3 rank1 ds4 ds5
                        -> case rank of wild2 { GHC.Types.I# x ->
                           case rank1 of wild3 { GHC.Types.I# y ->
                           case GHC.Prim.>=# x y of lwild {
                             DEFAULT
                             -> HeapImpl.HP @ a w (GHC.Types.I# (GHC.Prim.+# x 1#)) wild1 wild
                             1#
                             -> HeapImpl.HP
                                  @ a
                                  w
                                  (GHC.Types.I# (GHC.Prim.+# y 1#))
                                  wild
                                  wild1 } } } } }) -}
d74b655e611ea45eef106ddcc1c9dcef
  data Heap a
    = EmptyHP | HP a GHC.Types.Int (HeapImpl.Heap a) (HeapImpl.Heap a)
56f44df9f11ebba3f0614fad6253bbe1
  delHeap :: GHC.Classes.Ord a => HeapImpl.Heap a -> HeapImpl.Heap a
  {- Arity: 2, Strictness: <L,U(A,A,A,C(C1(U)),A,A,A,A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a ($dOrd :: GHC.Classes.Ord a) (ds :: HeapImpl.Heap a) ->
                 case ds of wild {
                   HeapImpl.EmptyHP -> HeapImpl.delHeap2 @ a
                   HeapImpl.HP element ds1 left right
                   -> HeapImpl.merge @ a $dOrd left right }) -}
6c16498057e0e8c569aefe18263538b9
  delHeap1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 1#) -}
70f8738e5e8440d7ec071a7a19f88458
  delHeap2 :: HeapImpl.Heap a
  {- Strictness: x -}
4522845c64ee18beb83014b5f35b6863
  delHeap_$smerge ::
    HeapImpl.Heap a
    -> a
    -> HeapImpl.Heap a
    -> HeapImpl.Heap a
    -> GHC.Classes.Ord a => HeapImpl.Heap a
  {- Arity: 5, HasNoCafRefs,
     Strictness: <S,1*U><L,U><L,U><L,U><L,U(A,A,A,C(C1(U)),A,A,A,A)>m2 -}
74d28fa4a935ea9f7e225ca83119c590
  delHeap_$smerge1 ::
    a
    -> GHC.Types.Int
    -> HeapImpl.Heap a
    -> HeapImpl.Heap a
    -> HeapImpl.Heap a
    -> GHC.Classes.Ord a => HeapImpl.Heap a
  {- Arity: 6, HasNoCafRefs,
     Strictness: <L,U><L,U><L,U><L,U><S,1*U><L,U(A,A,A,C(C1(U)),A,A,A,A)>m2 -}
270f6dd1093ac57a67ddf5fb2b23b7c7
  delHeap_$smerge2 ::
    HeapImpl.Heap a
    -> a
    -> GHC.Types.Int
    -> HeapImpl.Heap a
    -> HeapImpl.Heap a
    -> GHC.Classes.Ord a => HeapImpl.Heap a
  {- Arity: 6, HasNoCafRefs,
     Strictness: <S,1*U><L,U><L,U><L,U><L,U><L,U(A,A,A,C(C1(U)),A,A,A,A)>m2 -}
36fae98d41c86ba1f68a2b50e0cf2fe1
  emptyHeap :: HeapImpl.Heap a
  {- HasNoCafRefs,
     Unfolding: InlineRule (0, True, True) HeapImpl.EmptyHP -}
472221983fc492094e02d64762ce1357
  findHeap :: GHC.Classes.Ord a => HeapImpl.Heap a -> a
  {- Arity: 2, Strictness: <L,A>,
     Unfolding: InlineRule (1, True, True)
                (\ @ a ($dOrd :: GHC.Classes.Ord a) -> HeapImpl.findHeap1 @ a) -}
8246ec2d19d365b78a2236f861fe21c7
  findHeap1 :: HeapImpl.Heap a -> a
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds :: HeapImpl.Heap a) ->
                 case ds of wild {
                   HeapImpl.EmptyHP -> HeapImpl.findHeap2 @ a
                   HeapImpl.HP element ds1 left right -> element }) -}
8414eab17622ecac083c3d407e6808bd
  findHeap2 :: a
  {- Strictness: x -}
3c28bd30bb217a46e28767323e892ff8
  heapEmpty :: HeapImpl.Heap a -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds :: HeapImpl.Heap a) ->
                 case ds of wild {
                   HeapImpl.EmptyHP -> GHC.Types.True
                   HeapImpl.HP ipv ipv1 ipv2 ipv3 -> GHC.Types.False }) -}
57fb264abf4fa3d6a2b57f16fcd15a79
  insHeap ::
    GHC.Classes.Ord a => a -> HeapImpl.Heap a -> HeapImpl.Heap a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(A,A,A,C(C1(U)),A,A,A,A)><L,U><S,1*U>m2,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dOrd :: GHC.Classes.Ord a)
                   (element :: a)
                   (heap :: HeapImpl.Heap a) ->
                 HeapImpl.delHeap_$smerge
                   @ a
                   heap
                   element
                   (HeapImpl.EmptyHP @ a)
                   (HeapImpl.EmptyHP @ a)
                   $dOrd) -}
22be9e40ace07512d3e0867cb21ff401
  merge ::
    GHC.Classes.Ord a =>
    HeapImpl.Heap a -> HeapImpl.Heap a -> HeapImpl.Heap a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(A,A,A,C(C1(U)),A,A,A,A)><S,1*U><S,1*U>,
     Unfolding: (\ @ a
                   ($dOrd :: GHC.Classes.Ord a)
                   (heap :: HeapImpl.Heap a)
                   (ds :: HeapImpl.Heap a) ->
                 case ds of wild {
                   HeapImpl.EmptyHP -> heap
                   HeapImpl.HP ipv ipv1 ipv2 ipv3
                   -> case heap of wild1 {
                        HeapImpl.EmptyHP -> wild
                        HeapImpl.HP element1 ds1 left1 right1
                        -> case GHC.Classes.<= @ a $dOrd element1 ipv of wild2 {
                             GHC.Types.False
                             -> HeapImpl.$wmakeHP
                                  @ a
                                  ipv
                                  ipv2
                                  (HeapImpl.delHeap_$smerge2
                                     @ a
                                     ipv3
                                     element1
                                     ds1
                                     left1
                                     right1
                                     $dOrd)
                             GHC.Types.True
                             -> HeapImpl.$wmakeHP
                                  @ a
                                  element1
                                  left1
                                  (HeapImpl.delHeap_$smerge1
                                     @ a
                                     ipv
                                     ipv1
                                     ipv2
                                     ipv3
                                     right1
                                     $dOrd) } } }) -}
instance [safe] GHC.Show.Show [HeapImpl.Heap] = HeapImpl.$fShowHeap
"SC:$cshowsPrec0" forall @ a
                         (sc :: HeapImpl.Heap a)
                         (sc1 :: GHC.Prim.Int#)
                         (sc2 :: GHC.Show.Show a)
  HeapImpl.$fShowHeap_$cshowsPrec @ a sc2 (GHC.Types.I# sc1) sc
  = HeapImpl.$fShowHeap_$s$cshowsPrec @ a sc sc1 sc2
"SC:merge0" forall @ a
                   (sc :: HeapImpl.Heap a)
                   (sc1 :: a)
                   (sc2 :: HeapImpl.Heap a)
                   (sc3 :: HeapImpl.Heap a)
                   (sc4 :: GHC.Classes.Ord a)
  HeapImpl.merge @ a
                 sc4
                 (HeapImpl.HP @ a sc1 HeapImpl.delHeap1 sc2 sc3)
                 sc
  = HeapImpl.delHeap_$smerge @ a sc sc1 sc2 sc3 sc4
"SC:merge1" forall @ a
                   (sc :: a)
                   (sc1 :: GHC.Types.Int)
                   (sc2 :: HeapImpl.Heap a)
                   (sc3 :: HeapImpl.Heap a)
                   (sc4 :: HeapImpl.Heap a)
                   (sc5 :: GHC.Classes.Ord a)
  HeapImpl.merge @ a sc5 sc4 (HeapImpl.HP @ a sc sc1 sc2 sc3)
  = HeapImpl.delHeap_$smerge1 @ a sc sc1 sc2 sc3 sc4 sc5
"SC:merge2" forall @ a
                   (sc :: HeapImpl.Heap a)
                   (sc1 :: a)
                   (sc2 :: GHC.Types.Int)
                   (sc3 :: HeapImpl.Heap a)
                   (sc4 :: HeapImpl.Heap a)
                   (sc5 :: GHC.Classes.Ord a)
  HeapImpl.merge @ a sc5 (HeapImpl.HP @ a sc1 sc2 sc3 sc4) sc
  = HeapImpl.delHeap_$smerge2 @ a sc sc1 sc2 sc3 sc4 sc5
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

